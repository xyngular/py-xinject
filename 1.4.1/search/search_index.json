{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Install \u00b6 1 2 3 4 5 # via pip pip install xinject # via poetry poetry add xinject Introduction \u00b6 Main focus is an easy way to create lazy universally injectable dependencies; in less magical way. It also leans more on the side of making it easier to get the dependency you need anywhere in the codebase. py-xinject allows you to easily inject lazily created universal dependencies into whatever code that needs them, in an easy to understand and self-documenting way. xinject is short for \"Universal Dependency\" ie: a lazy universally injectable dependency Note Read this document first to get a general overview before reading the API reference documentation. When you're done here and want more details go to API Reference or directly to Dependency API Refrence for more detailed reference-type documentation. Quick Start \u00b6 Although it's not required, most of the time you'll want to subclass Dependency . The subclass will inherit some nice features that make it easier to use. The following is a specific usecase followed by a more generalized example Lazy S3 Resource Dependency Example \u00b6 Here is a very basic injectable/sharable lazily created S3 resource. We have a choice to inherit from ether Dependency, or DependencyPerThread. The normal Dependency class lets the dependency be shared between threads, so more of a true singleton type of object where under normal/default circomstances there would ever only be one instance of a partculare Dependency . Using DependencyPerThread will automatically get a separate dependency object per-thread (ie: separate instance per-thread). It simply inherits from Dependency and configures it to not be thread sharable. In the example below, we do that with the Boto resource, as the boto documentation for resources states they are not thread-safe. That means our program will need a separate s3 resource per-thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 # This is the \"my_resources.py\" file/module. import boto3 from xinject import DependencyPerThread class S3 ( DependencyPerThread ): def __init__ ( self , ** kwargs ): # Keeping this simple; a more complex version # may store the `kwargs` and lazily create the s3 resource # only when it's asked for (via a `@property or some such). self . resource = boto3 . resource ( 's3' , ** kwargs ) To use this resource in any codebase, you can do this: 1 2 3 4 5 6 7 8 9 # This is the \"my_functions.py\" file/module from .my_resources import S3 def download_file ( file_name , dest_path ): s3_resource = S3 . grab () . resource s3_resource . Bucket ( 'my-bucket' ) . download_file ( file_name , dest_path ) When grab_file is called it will grab the current S3 dependency and get the resource off of it. If S3 dependency has not been created yet, it will do so on the fly and store and return the lazily created dependency in the future when asked for it. This means, the resource is only created when it needs to be. Inject Temporarily \u00b6 Now, let's say you wanted to change/inject a different version of the S3 dependency, you could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from .my_resources import S3 from .my_functions import download_file us_west_s3_resource = S3 ( region_name = 'us-west-2' ) def get_s3_file_from_us_west ( file , dest_path ): # Can use Dependencies as a context-manager, # inject `use_west_s3_resource` inside `with`: with us_west_s3_resource : download_file ( file , dest_path ) # Can also use Dependencies as a function decorator, # inject `use_west_s3_resource` whenever this method is called. @us_west_s3_resource def get_s3_file_from_us_west ( file , dest_path ): download_file ( file , dest_path ) All classes that inherit from Dependency are context managers, and so the with statement will 'activate' that dependency as the current version to use. That will inject an S3 resource configured with region_name='us-west-2 into the function you are calling. It does not matter how many other methods needs to be called to get to the method that needs the S3 resource, it would still be injected and used. After the with statement is exited, the previous S3 instance (if any) that was active before the with statement is now what is used from that point forward. This allows you to decouple the code. Code that needs a resource can grab it from the S3 class, and code that needs to configure the resource can do so without having to know exactly what other methods needs that dependency. It can configure the dependencies as/if needed, start the app/process and be done. The resource also sticks around inside the dependency, and can be reused/shared. This allows the boto3 s3 resource (in the example above) to reuse already opened TCP connections to s3 as the s3 resource is used from various parts of the code base. Inject Permanently \u00b6 If instead (see previous example) you don't want to temporarily inject a dependency, but instead permanently do it you can do so in a few ways: Change the current dependency by setting attributes or calling methods on it. Replace the current dependency with a different object. The first way is easy, you just access the current version of the resource. I'll be using the S3 dependency from the previous example: 1 2 from .my_resources import S3 S3 . grab () . resource = boto . resource ( 's3' , region_name = 'us-west-2' ) In this case, I am replacing the resource attribute on the S3 current dependency instance/object with my own version of the resource. From this point forward, it will be what is used (unless some other code after this point temporarily injects their own resource via a with ; see previous example). Fro the second way, you can access the repository of dependencies and swap/inject a different resource there. This will add the dependency to the current context, and when that dependency is next asked for it will return the one that was added here: 1 2 3 4 5 from xinject import XContext from .my_resources import S3 us_west_s3_resource = S3 ( region_name = 'us-west-2' ) XContext . grab () . add ( us_west_s3_resource ) And finally, you can replace dependencies with a completely different class of object. This is sometimes useful when doing unit-testing. What we do here is add out special MyS3MockingClass object and tell context to use this in place for the S3 type dependency. In the future, this mocking object will be returned when the code asks for the S3 dependency-type. 1 2 3 4 5 6 from xinject import XContext from .my_resources import S3 from .my_mocks import MyS3MockingClass s3_mocking_obj = MyS3MockingClass () XContext . grab () . add ( s3_mocking_obj , for_type = S3 ) Generalized/Generic Example \u00b6 Although it's not required, most of the time you'll want to subclass Dependency . The subclass will inherit some nice features that make it easier to use. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from xinject import Dependency # This is an example Dependency class, the intent with this class # is to treat it as a semi-singleton shared dependency. class MyUniversalDependency ( Dependency ): # It's important to allow dependencies to be allocated with # no required init arguments. # That way a default-instance/version of the class can # easily be created lazily. def __init__ ( self , name = None ): if name is not None : self . name = name name : str = 'original-value' # Gets currently active instance of `MyUniversalDependency`, # or lazily creates if needed. If system creates a new # instance of MyUniversalDependency, it will save it and # reuse it in the future when it's asked for. # # Next, we get value of it's `name` attribute: assert MyUniversalDependency . grab () . name == 'original-value' # Change the value of the name attribute on current dependency MyUniversalDependency . grab () . name = 'changed-value' # We still have access to the same object, so it has the new value: assert MyUniversalDependency . grab () . name == 'changed-value' # Inherit from Dependency allows you to use them as a context manager. # This allows you to easily/temporarily inject dependencies: with MyUniversalDependency ( name = 'injected-value' ): # When someone asks for the current dependency of `MyResource`, # they will get the one I created in `with` statement above. assert MyUniversalDependency . grab () . name == 'injected-value' # Object we created and temporary activated/injected # by above `with` statement has been deactivated/uninjected. # So, the previous object is what is now used: assert MyUniversalDependency . grab () . name == 'changed-value' There is also a way to get a proxy-object that represents the currently used object. This allows you to have an object that is directly importable/usable and still have it be injectable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from xinject import Dependency class MyUniversalDependency ( Dependency ): def __init__ ( self , name = 'default-value' ): self . name = name my_universal_dependency = MyUniversalDependency . proxy () assert my_universal_dependency . name == 'changing-the-value' with MyUniversalDependency ( name = 'injected-value' ): # The proxy object proxies to the currently activated/injected # version of the dependency: assert my_universal_dependency . name == 'injected-value' Overview \u00b6 The main class used most of the time is Dependency . Allows you to create sub-classes that act as sharable singleton-type objects that we are calling resources here. These are also typically objects that should generally stick around and should be created lazily. Also allows code to temporarily create, customize and activate a dependency if you don't want the customization to stick around permanently. You can do it without your or other code needing to be aware of each other. This helps promote code decoupling, since it's so easy to make a Dependency activate it as the 'current' version to use. The only coupling that takes place is to the Dependency sub-class it's self. Each separate piece of code can be completely unaware of each other, and yet each one can take advantage of the shared dependency. This means that Dependency can also help with simple dependency injection use-case scenarios. What It's Used For \u00b6 Lazily created singleton-type objects that you can still override/inject as needed in a decoupled fashion. Supports foster decoupled code by making it easy to use dependency injection code patterns. Lazily created resources, like api clients. Helps with unit testing mock frameworks. Example: moto needs boto clients to be created after unit test starts, so it can intercept and mock it. Using a dependency to get boto client allows them to be lazily created/mocked during each unit-test run. Lazily create sharable objects on demand when/where needed. Things that need to be shared in many locations, without having to pass them everywhere, or couple the code together. Example: session from requests library, so code can re-use already open TCP connections to an API. Example Use Cases \u00b6 Network connection and/or a remote dependency/client. You can wrap these objects in a dependency , the dependency provides the object. Objects to wrap are 'client' like things, and allow you to communicate with some external system. Very common for these objects to represent an already-open network connection, So there are performance considerations to try and keep connection open and to reuse it. Common configuration or setting objects. Anything that needs to be lazily allocated, especially if they need to be re-created for each unit-test run. Since all dependencies are thrown-away before running each unit-test function, all dependencies will be lazily re-created each time by default. Examples: moto You need to create boto clients after moto is setup in order for moto to intercept/mock the service the boto client uses. But you also don't want the main code base to create a brand new boto client each time it needs it, so that it can reuse/share already established TCP connections. Using a Dependency to lazily manage your boto clients solves both of these issues. requests-mock Requests-mock needs to be in place before the code base creates a requests-session You want to use a session in main code base to reuse/share already established TCP connections to your http apis. Using a Dependency to manage a shared requests session lets you both lazily create the session to help with unit testing, but also allows you to easily reuse the session in your codebase in a decoupled manner. Basic dependency injection scenarios, where two separate pieces of code need to use a shared object of some sort that you want to 'inject' into them. Does it in a way that prevents you having to pass around the object manually everywhere. Promotes code-decoupling, since there is less-temptation to couple them if it's easy to share what they need between each-other, without having each piece of code having to know about each-other.","title":"Getting Started"},{"location":"#install","text":"1 2 3 4 5 # via pip pip install xinject # via poetry poetry add xinject","title":"Install"},{"location":"#introduction","text":"Main focus is an easy way to create lazy universally injectable dependencies; in less magical way. It also leans more on the side of making it easier to get the dependency you need anywhere in the codebase. py-xinject allows you to easily inject lazily created universal dependencies into whatever code that needs them, in an easy to understand and self-documenting way. xinject is short for \"Universal Dependency\" ie: a lazy universally injectable dependency Note Read this document first to get a general overview before reading the API reference documentation. When you're done here and want more details go to API Reference or directly to Dependency API Refrence for more detailed reference-type documentation.","title":"Introduction"},{"location":"#quick-start","text":"Although it's not required, most of the time you'll want to subclass Dependency . The subclass will inherit some nice features that make it easier to use. The following is a specific usecase followed by a more generalized example","title":"Quick Start"},{"location":"#lazy-s3-resource-dependency-example","text":"Here is a very basic injectable/sharable lazily created S3 resource. We have a choice to inherit from ether Dependency, or DependencyPerThread. The normal Dependency class lets the dependency be shared between threads, so more of a true singleton type of object where under normal/default circomstances there would ever only be one instance of a partculare Dependency . Using DependencyPerThread will automatically get a separate dependency object per-thread (ie: separate instance per-thread). It simply inherits from Dependency and configures it to not be thread sharable. In the example below, we do that with the Boto resource, as the boto documentation for resources states they are not thread-safe. That means our program will need a separate s3 resource per-thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 # This is the \"my_resources.py\" file/module. import boto3 from xinject import DependencyPerThread class S3 ( DependencyPerThread ): def __init__ ( self , ** kwargs ): # Keeping this simple; a more complex version # may store the `kwargs` and lazily create the s3 resource # only when it's asked for (via a `@property or some such). self . resource = boto3 . resource ( 's3' , ** kwargs ) To use this resource in any codebase, you can do this: 1 2 3 4 5 6 7 8 9 # This is the \"my_functions.py\" file/module from .my_resources import S3 def download_file ( file_name , dest_path ): s3_resource = S3 . grab () . resource s3_resource . Bucket ( 'my-bucket' ) . download_file ( file_name , dest_path ) When grab_file is called it will grab the current S3 dependency and get the resource off of it. If S3 dependency has not been created yet, it will do so on the fly and store and return the lazily created dependency in the future when asked for it. This means, the resource is only created when it needs to be.","title":"Lazy S3 Resource Dependency Example"},{"location":"#inject-temporarily","text":"Now, let's say you wanted to change/inject a different version of the S3 dependency, you could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from .my_resources import S3 from .my_functions import download_file us_west_s3_resource = S3 ( region_name = 'us-west-2' ) def get_s3_file_from_us_west ( file , dest_path ): # Can use Dependencies as a context-manager, # inject `use_west_s3_resource` inside `with`: with us_west_s3_resource : download_file ( file , dest_path ) # Can also use Dependencies as a function decorator, # inject `use_west_s3_resource` whenever this method is called. @us_west_s3_resource def get_s3_file_from_us_west ( file , dest_path ): download_file ( file , dest_path ) All classes that inherit from Dependency are context managers, and so the with statement will 'activate' that dependency as the current version to use. That will inject an S3 resource configured with region_name='us-west-2 into the function you are calling. It does not matter how many other methods needs to be called to get to the method that needs the S3 resource, it would still be injected and used. After the with statement is exited, the previous S3 instance (if any) that was active before the with statement is now what is used from that point forward. This allows you to decouple the code. Code that needs a resource can grab it from the S3 class, and code that needs to configure the resource can do so without having to know exactly what other methods needs that dependency. It can configure the dependencies as/if needed, start the app/process and be done. The resource also sticks around inside the dependency, and can be reused/shared. This allows the boto3 s3 resource (in the example above) to reuse already opened TCP connections to s3 as the s3 resource is used from various parts of the code base.","title":"Inject Temporarily"},{"location":"#inject-permanently","text":"If instead (see previous example) you don't want to temporarily inject a dependency, but instead permanently do it you can do so in a few ways: Change the current dependency by setting attributes or calling methods on it. Replace the current dependency with a different object. The first way is easy, you just access the current version of the resource. I'll be using the S3 dependency from the previous example: 1 2 from .my_resources import S3 S3 . grab () . resource = boto . resource ( 's3' , region_name = 'us-west-2' ) In this case, I am replacing the resource attribute on the S3 current dependency instance/object with my own version of the resource. From this point forward, it will be what is used (unless some other code after this point temporarily injects their own resource via a with ; see previous example). Fro the second way, you can access the repository of dependencies and swap/inject a different resource there. This will add the dependency to the current context, and when that dependency is next asked for it will return the one that was added here: 1 2 3 4 5 from xinject import XContext from .my_resources import S3 us_west_s3_resource = S3 ( region_name = 'us-west-2' ) XContext . grab () . add ( us_west_s3_resource ) And finally, you can replace dependencies with a completely different class of object. This is sometimes useful when doing unit-testing. What we do here is add out special MyS3MockingClass object and tell context to use this in place for the S3 type dependency. In the future, this mocking object will be returned when the code asks for the S3 dependency-type. 1 2 3 4 5 6 from xinject import XContext from .my_resources import S3 from .my_mocks import MyS3MockingClass s3_mocking_obj = MyS3MockingClass () XContext . grab () . add ( s3_mocking_obj , for_type = S3 )","title":"Inject Permanently"},{"location":"#generalizedgeneric-example","text":"Although it's not required, most of the time you'll want to subclass Dependency . The subclass will inherit some nice features that make it easier to use. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from xinject import Dependency # This is an example Dependency class, the intent with this class # is to treat it as a semi-singleton shared dependency. class MyUniversalDependency ( Dependency ): # It's important to allow dependencies to be allocated with # no required init arguments. # That way a default-instance/version of the class can # easily be created lazily. def __init__ ( self , name = None ): if name is not None : self . name = name name : str = 'original-value' # Gets currently active instance of `MyUniversalDependency`, # or lazily creates if needed. If system creates a new # instance of MyUniversalDependency, it will save it and # reuse it in the future when it's asked for. # # Next, we get value of it's `name` attribute: assert MyUniversalDependency . grab () . name == 'original-value' # Change the value of the name attribute on current dependency MyUniversalDependency . grab () . name = 'changed-value' # We still have access to the same object, so it has the new value: assert MyUniversalDependency . grab () . name == 'changed-value' # Inherit from Dependency allows you to use them as a context manager. # This allows you to easily/temporarily inject dependencies: with MyUniversalDependency ( name = 'injected-value' ): # When someone asks for the current dependency of `MyResource`, # they will get the one I created in `with` statement above. assert MyUniversalDependency . grab () . name == 'injected-value' # Object we created and temporary activated/injected # by above `with` statement has been deactivated/uninjected. # So, the previous object is what is now used: assert MyUniversalDependency . grab () . name == 'changed-value' There is also a way to get a proxy-object that represents the currently used object. This allows you to have an object that is directly importable/usable and still have it be injectable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from xinject import Dependency class MyUniversalDependency ( Dependency ): def __init__ ( self , name = 'default-value' ): self . name = name my_universal_dependency = MyUniversalDependency . proxy () assert my_universal_dependency . name == 'changing-the-value' with MyUniversalDependency ( name = 'injected-value' ): # The proxy object proxies to the currently activated/injected # version of the dependency: assert my_universal_dependency . name == 'injected-value'","title":"Generalized/Generic Example"},{"location":"#overview","text":"The main class used most of the time is Dependency . Allows you to create sub-classes that act as sharable singleton-type objects that we are calling resources here. These are also typically objects that should generally stick around and should be created lazily. Also allows code to temporarily create, customize and activate a dependency if you don't want the customization to stick around permanently. You can do it without your or other code needing to be aware of each other. This helps promote code decoupling, since it's so easy to make a Dependency activate it as the 'current' version to use. The only coupling that takes place is to the Dependency sub-class it's self. Each separate piece of code can be completely unaware of each other, and yet each one can take advantage of the shared dependency. This means that Dependency can also help with simple dependency injection use-case scenarios.","title":"Overview"},{"location":"#what-its-used-for","text":"Lazily created singleton-type objects that you can still override/inject as needed in a decoupled fashion. Supports foster decoupled code by making it easy to use dependency injection code patterns. Lazily created resources, like api clients. Helps with unit testing mock frameworks. Example: moto needs boto clients to be created after unit test starts, so it can intercept and mock it. Using a dependency to get boto client allows them to be lazily created/mocked during each unit-test run. Lazily create sharable objects on demand when/where needed. Things that need to be shared in many locations, without having to pass them everywhere, or couple the code together. Example: session from requests library, so code can re-use already open TCP connections to an API.","title":"What It's Used For"},{"location":"#example-use-cases","text":"Network connection and/or a remote dependency/client. You can wrap these objects in a dependency , the dependency provides the object. Objects to wrap are 'client' like things, and allow you to communicate with some external system. Very common for these objects to represent an already-open network connection, So there are performance considerations to try and keep connection open and to reuse it. Common configuration or setting objects. Anything that needs to be lazily allocated, especially if they need to be re-created for each unit-test run. Since all dependencies are thrown-away before running each unit-test function, all dependencies will be lazily re-created each time by default. Examples: moto You need to create boto clients after moto is setup in order for moto to intercept/mock the service the boto client uses. But you also don't want the main code base to create a brand new boto client each time it needs it, so that it can reuse/share already established TCP connections. Using a Dependency to lazily manage your boto clients solves both of these issues. requests-mock Requests-mock needs to be in place before the code base creates a requests-session You want to use a session in main code base to reuse/share already established TCP connections to your http apis. Using a Dependency to manage a shared requests session lets you both lazily create the session to help with unit testing, but also allows you to easily reuse the session in your codebase in a decoupled manner. Basic dependency injection scenarios, where two separate pieces of code need to use a shared object of some sort that you want to 'inject' into them. Does it in a way that prevents you having to pass around the object manually everywhere. Promotes code-decoupling, since there is less-temptation to couple them if it's easy to share what they need between each-other, without having each piece of code having to know about each-other.","title":"Example Use Cases"},{"location":"changelog/","text":"Changelog \u00b6 1.4.1 (2023-04-15) \u00b6 Bug Fixes \u00b6 license ( 709f49e ) 1.4.0 (2023-02-19) \u00b6 Features \u00b6 have proxy also forward set/get item dunder methods. ( e471b71 ) 1.3.0 (2023-02-03) \u00b6 Features \u00b6 added ability to easily proxy an attribute on dependency. ( 0ff42a0 ) Bug Fixes \u00b6 style, add doc comment. ( 3ad3817 ) 1.2.0 (2023-01-02) \u00b6 Features \u00b6 renamed resource-refs to dependency-refs terminology; ie: resource_chain() -&gt; dependency_chain() ( f1f7b08 ) 1.1.0 (2022-12-13) \u00b6 Features \u00b6 update deps. ( 0c49054 ) Bug Fixes \u00b6 fixes a bug where if you activate a dependency before the thread-root context is created. ( 0bb778c ) 1.0.2 (2022-11-20) \u00b6 Documentation \u00b6 fix readme pypi pointer. ( e775c81 ) 1.0.1 (2022-11-20) \u00b6 Bug Fixes \u00b6 add missing metadata to package. ( ced4cea ) 1.0.0 (2022-11-20) \u00b6 Features \u00b6 release as version 1.0.0 ( a971752 ) 0.4.0 (2022-11-20) \u00b6 Features \u00b6 added obj class property on Dependency to more easily get current dependency object. ( e7de56e ) precent context from copying unless needed. ( 3e0940c ) Proxy str/repr functions. ( 0991475 ) rearranged docs to make them more clear. ( 2d55d38 ) rename ActiveResourceProxy to CurrentDependencyProxy ( 5474533 ) rename file to new name. ( e5bf973 ) rename library to final name xinject . ( be567e4 ) renamed resource() into grab() , a simpler and more obvious name for what it does. ( aafcec8 ) renamed glazy into udepend in general. ( f302abe ) renamed guards to xsentinels. ( 750d987 ) return self if calling dependency without args (supports future Dependency.grab() syntax). ( c2ebe5b ) simplified grab method; updated doc-comment; renamed to DependecyPerThread. ( 40a2052 ) Bug Fixes \u00b6 doc links ( 4d0fdb0 ) doc-comments + thread-sharable feature. ( 2da6a76 ) forgot to rename UDependError to XInjectError. ( 7c4bf11 ) more emphasis on doc-link. ( 325a191 ) use NotImplementedError instead of just NotImplemented. ( 24dbaa0 ) Documentation \u00b6 capitalized API Reference ( a82f9ed ) fix readme. ( f2990d5 ) fix references to Context to fully qualified UContext . ( 6558f12 ) grammer fix ( c40f472 ) Majorly improve documentation. ( 5b0af23 ) splitting up docs into multiple files. ( 71fee52 ) 0.3.0 (2022-10-08) \u00b6 Features \u00b6 add api docs ref, change-log... ( f3ffaed ) add docs. ( bec0deb ) Bug Fixes \u00b6 accidentally added .html files... ( 4fb10b4 ) remove unneeded input to reusable workflow call. ( 040e4fd ) test-release-process. ( b9c6d8c ) 0.2.0 (2022-10-08) \u00b6 Features \u00b6 initial code import; experimental; DO NOT USE!!! ( ace5177 ) Bug Fixes \u00b6 correct package to include name. ( 2d481b4 ) 0.1.0 (2022-10-08) \u00b6 Features \u00b6 initial code import; experimental; DO NOT USE!!! ( ace5177 ) Bug Fixes \u00b6 correct package to include name. ( 2d481b4 )","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#141-2023-04-15","text":"","title":"1.4.1 (2023-04-15)"},{"location":"changelog/#bug-fixes","text":"license ( 709f49e )","title":"Bug Fixes"},{"location":"changelog/#140-2023-02-19","text":"","title":"1.4.0 (2023-02-19)"},{"location":"changelog/#features","text":"have proxy also forward set/get item dunder methods. ( e471b71 )","title":"Features"},{"location":"changelog/#130-2023-02-03","text":"","title":"1.3.0 (2023-02-03)"},{"location":"changelog/#features_1","text":"added ability to easily proxy an attribute on dependency. ( 0ff42a0 )","title":"Features"},{"location":"changelog/#bug-fixes_1","text":"style, add doc comment. ( 3ad3817 )","title":"Bug Fixes"},{"location":"changelog/#120-2023-01-02","text":"","title":"1.2.0 (2023-01-02)"},{"location":"changelog/#features_2","text":"renamed resource-refs to dependency-refs terminology; ie: resource_chain() -&gt; dependency_chain() ( f1f7b08 )","title":"Features"},{"location":"changelog/#110-2022-12-13","text":"","title":"1.1.0 (2022-12-13)"},{"location":"changelog/#features_3","text":"update deps. ( 0c49054 )","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"fixes a bug where if you activate a dependency before the thread-root context is created. ( 0bb778c )","title":"Bug Fixes"},{"location":"changelog/#102-2022-11-20","text":"","title":"1.0.2 (2022-11-20)"},{"location":"changelog/#documentation","text":"fix readme pypi pointer. ( e775c81 )","title":"Documentation"},{"location":"changelog/#101-2022-11-20","text":"","title":"1.0.1 (2022-11-20)"},{"location":"changelog/#bug-fixes_3","text":"add missing metadata to package. ( ced4cea )","title":"Bug Fixes"},{"location":"changelog/#100-2022-11-20","text":"","title":"1.0.0 (2022-11-20)"},{"location":"changelog/#features_4","text":"release as version 1.0.0 ( a971752 )","title":"Features"},{"location":"changelog/#040-2022-11-20","text":"","title":"0.4.0 (2022-11-20)"},{"location":"changelog/#features_5","text":"added obj class property on Dependency to more easily get current dependency object. ( e7de56e ) precent context from copying unless needed. ( 3e0940c ) Proxy str/repr functions. ( 0991475 ) rearranged docs to make them more clear. ( 2d55d38 ) rename ActiveResourceProxy to CurrentDependencyProxy ( 5474533 ) rename file to new name. ( e5bf973 ) rename library to final name xinject . ( be567e4 ) renamed resource() into grab() , a simpler and more obvious name for what it does. ( aafcec8 ) renamed glazy into udepend in general. ( f302abe ) renamed guards to xsentinels. ( 750d987 ) return self if calling dependency without args (supports future Dependency.grab() syntax). ( c2ebe5b ) simplified grab method; updated doc-comment; renamed to DependecyPerThread. ( 40a2052 )","title":"Features"},{"location":"changelog/#bug-fixes_4","text":"doc links ( 4d0fdb0 ) doc-comments + thread-sharable feature. ( 2da6a76 ) forgot to rename UDependError to XInjectError. ( 7c4bf11 ) more emphasis on doc-link. ( 325a191 ) use NotImplementedError instead of just NotImplemented. ( 24dbaa0 )","title":"Bug Fixes"},{"location":"changelog/#documentation_1","text":"capitalized API Reference ( a82f9ed ) fix readme. ( f2990d5 ) fix references to Context to fully qualified UContext . ( 6558f12 ) grammer fix ( c40f472 ) Majorly improve documentation. ( 5b0af23 ) splitting up docs into multiple files. ( 71fee52 )","title":"Documentation"},{"location":"changelog/#030-2022-10-08","text":"","title":"0.3.0 (2022-10-08)"},{"location":"changelog/#features_6","text":"add api docs ref, change-log... ( f3ffaed ) add docs. ( bec0deb )","title":"Features"},{"location":"changelog/#bug-fixes_5","text":"accidentally added .html files... ( 4fb10b4 ) remove unneeded input to reusable workflow call. ( 040e4fd ) test-release-process. ( b9c6d8c )","title":"Bug Fixes"},{"location":"changelog/#020-2022-10-08","text":"","title":"0.2.0 (2022-10-08)"},{"location":"changelog/#features_7","text":"initial code import; experimental; DO NOT USE!!! ( ace5177 )","title":"Features"},{"location":"changelog/#bug-fixes_6","text":"correct package to include name. ( 2d481b4 )","title":"Bug Fixes"},{"location":"changelog/#010-2022-10-08","text":"","title":"0.1.0 (2022-10-08)"},{"location":"changelog/#features_8","text":"initial code import; experimental; DO NOT USE!!! ( ace5177 )","title":"Features"},{"location":"changelog/#bug-fixes_7","text":"correct package to include name. ( 2d481b4 )","title":"Bug Fixes"},{"location":"dataclasses/","text":"Dependency + Dataclasses \u00b6 You can use the built-in dataclasses with Dependency without a problem. Just ensure all fields are optional (ie: they all have default values), so they are not required when creating/init'ing the object. You can also provide a __post_init__ method on your Dependency subclass to help you initialize the values into a good default state (a standard feature of dataclasses). The purpose to enable lazily creation of the Dependency object the very first time it's asked for. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from xinject import Dependency from dataclasses import dataclass @dataclass class DataResource ( Dependency ): # Making all fields optional, so DataResource can be created lazily: my_optional_field : str = None another_optional_field : str = \"hello!\" # Get current DataResource dependency, print it's another_optional_field; # will print out `hello!`: print ( DataResource . grab () . another_optional_field ) DataResource . grab () DataResource . grab () DataResource . grab ()","title":"Data Classes"},{"location":"dataclasses/#dependency-dataclasses","text":"You can use the built-in dataclasses with Dependency without a problem. Just ensure all fields are optional (ie: they all have default values), so they are not required when creating/init'ing the object. You can also provide a __post_init__ method on your Dependency subclass to help you initialize the values into a good default state (a standard feature of dataclasses). The purpose to enable lazily creation of the Dependency object the very first time it's asked for. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from xinject import Dependency from dataclasses import dataclass @dataclass class DataResource ( Dependency ): # Making all fields optional, so DataResource can be created lazily: my_optional_field : str = None another_optional_field : str = \"hello!\" # Get current DataResource dependency, print it's another_optional_field; # will print out `hello!`: print ( DataResource . grab () . another_optional_field ) DataResource . grab () DataResource . grab () DataResource . grab ()","title":"Dependency + Dataclasses"},{"location":"dependency-proxy/","text":"You can use the method Dependency.proxy() to easily get a proxy object. All non-dunder attributes/methods will be grabbed/set on the current object instead of the proxy. This means you can call all non-special methods and access normal attributes, as if the object was really the currently active dependency instance. Any methods/attributes that start with a _ will not be used on the proxied object, but will be used on only the proxy-object it's self. This means, you should not ask/set any attributes that start with _ (underscore) when using the proxy object. Here is an example boto3 s3 resource dependency: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # This is the \"my_resources.py\" file/module. from xinject import Dependency import boto3 from xinject import DependencyPerThread class S3 ( DependencyPerThread ): def __init__ ( self , ** kwargs ): self . resource = boto3 . resource ( 's3' , ** kwargs ) # The `Dependency.proxy.CurrentDependencyProxy.wrap` method to get # a correctly type-hinted (for IDE) proxy back: s3 = S3 . proxy () You can import the proxy and use it as if it's the current S3 object: 1 2 3 4 5 6 7 8 9 10 11 12 13 # This is the download_file.py file. # Import proxy object from my module (lower-case version) from .my_resources import s3 import sys if __name__ == '__main__' : file_name = sys . argv [ 0 ] dest_path = sys . argv [ 1 ] # Call normal attributes/properties/methods on it like normal, # the `s3` proxy will forward them to the current/injected object. s3 . resource . Bucket ( \"my-bucket\" ) . download_file ( file_name , dest_path ) You can use the proxy object like a normal object. The only things not forwarded are any method/attribute that starts with a _ , which conveays the attribute as private/internal. This includes any dunder-methods, they are not forarded either. Only use the proxy object for normal attribute/properties/methods. If you need do use an attribute/method that starts with an underscore _ , grab the current object directly via S3.grab() . The grab() method returns the current real object each time it's called (and not a proxy).","title":"Dependency Proxy"},{"location":"thread-safety/","text":"There is a concept of an app-root, and thread-root XContext . The app-root stores dependecies that can be shared between threads, whule the thread-root context stores dependence for a specific thread. By default, each Dependency subclass can be shared between different threads, ie: it's assumed to be thread-safe. You can indicate a Dependency subclass should not be shared between threads by inheriting from xinject.dependency.DependencyPerThread instead, or by setting the class attribute (on your subclass of Dependency) thread_sharable to False ; ie: 1 2 3 4 5 6 7 from xinject import Dependency , DependencyPerThread class MyThreadUnsafeDependencyOpt1 ( DependencyPerThread ): ... class MyThreadUnsafeDependencyOpt2 ( Dependency , thread_sharable = False ): ... Things that are probably not thread-safe in general are resources that contain network/remote type connections/sessions/clients. Example for which you would want a separate dependency instance/object per-thread: requests library session Requests libraries session object is not thread-safe, there is issue that's been around for 7 years to make it thread safe that's still open. For now, you need a seperate requests Session per-thread. requests-mock also needs the session created after it's setup, so after unit test runs. boto client/dependency Library says it's not thread-safe, you need to use a different object per-thread. Moto mocking library for AWS services needs you to allocate a client after it's setup, (so lazily allocate client/dependency from boto).","title":"Thread Safety"},{"location":"unit-testing/","text":"Overview - pytest \u00b6 Library has a pytest plugin, with the objective of clearing out dependencies at the start of each unit test run. This use useful when session/clients needs to be created after a mock installed. If the code-base uses a Dependency to grab a requests-session (for example), when a new unit-test runs it will allocate a new requests session, and mock will therefore work and start out blank, ready to be configured by the unit-test function that is currently running. While at the same time the code in prod/deployed code it will just use a shared session via the dependency, as that will stick around between lambda events, and so on and allow code to reuse already established connections (which is what you want to happen in deployed code). All you need to do is write a normal unit-test to take advantage of this feature: 1 2 3 4 5 6 7 8 9 10 11 12 13 # This is the \"my_library/my_resources.py\" file/module. import boto3 from xinject import DependencyPerThread class S3 ( DependencyPerThread ): def __init__ ( self , ** kwargs ): # Keeping this simple; a more complex version # may store the `kwargs` and lazily create the s3 resource # only when it's asked for (via a `@property or some such). self . resource = boto3 . resource ( 's3' , ** kwargs ) 1 2 3 4 5 6 7 # This is the \"my_library/my_functions.py\" file/module from .my_resources import S3 def download_file ( file_name , dest_path ): S3 . grab () . resource . Bucket ( 'my-bucket' ) . download_file ( file_name , dest_path ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # This is a unit-testing file/module from my_library.my_resources import S3 from my_library.my_functions import download_file from moto import mock_s3 import tempfile import pytest @mock_s3 @pytest . mark . parametrize ( \"test_file\" , [ \"a-file-1.txt\" , \"a-file-2.txt\" ], ) def test_download_file ( test_file ): \"\"\" `test_download_file` will be executed twice, once for each parameterized value. At the start of each run of the `test_download_file` function (once for each parameterized value), the dependencies are cleared. This means `S3.grab()` will create a S3 resource for me lazily each time this unit-test function runs. And so I can have separate, independent tests that won't leak dependencies into the next function test-run. \"\"\" S3 . grab () . resource . Bucket ( 'my-bucket' ) . put_object ( Key = test_file , Body = b 'some-bytes' ) with tempfile . NamedTemporaryFile () as tmp : download_file ( test_file , tmp . name ) with open ( tmp . name , 'r' ) as file : assert file . read () == b 'some-bytes' Implementation Details \u00b6 This is just extra info in case your intrested. Before the start of each pytest unit-test function run, the current dependencies are deactivated and a new blank XContext (which contains the dependencies) is created. This means that by default, at the start of each running unit test function there will be no dependencies 'visible'. PyTest Plugin Details This project contains a pytest plugin to automatically install a brand-new app-root and thread-root XContext's at the start of each unit test run. This is important, it ensures a blank root-context is used each time a unit test executes. This is accomplished via an autouse=True fixture. The fixture is in a pytest plugin module. This plugin module is automatically found and loaded by pytest. pytest checks all installed dependencies in the environment it runs in, so as long as xinject is installed in the environment as a dependency it will find this and autoload this fixture for each unit test. If curious The xinject_test_context fixture is how it's implemented. The result is for each unit test executed via pytest, it will always start with no resources from a previous unit-test execution. So no dependencies changes/state will 'leak' between each unit test function run. Each unit-test will therefore always start out in the same state. This allows each unit test to run in any order, as it should not affect the dependencies of the next unit-test function that runs.","title":"Unit Testing"},{"location":"unit-testing/#overview-pytest","text":"Library has a pytest plugin, with the objective of clearing out dependencies at the start of each unit test run. This use useful when session/clients needs to be created after a mock installed. If the code-base uses a Dependency to grab a requests-session (for example), when a new unit-test runs it will allocate a new requests session, and mock will therefore work and start out blank, ready to be configured by the unit-test function that is currently running. While at the same time the code in prod/deployed code it will just use a shared session via the dependency, as that will stick around between lambda events, and so on and allow code to reuse already established connections (which is what you want to happen in deployed code). All you need to do is write a normal unit-test to take advantage of this feature: 1 2 3 4 5 6 7 8 9 10 11 12 13 # This is the \"my_library/my_resources.py\" file/module. import boto3 from xinject import DependencyPerThread class S3 ( DependencyPerThread ): def __init__ ( self , ** kwargs ): # Keeping this simple; a more complex version # may store the `kwargs` and lazily create the s3 resource # only when it's asked for (via a `@property or some such). self . resource = boto3 . resource ( 's3' , ** kwargs ) 1 2 3 4 5 6 7 # This is the \"my_library/my_functions.py\" file/module from .my_resources import S3 def download_file ( file_name , dest_path ): S3 . grab () . resource . Bucket ( 'my-bucket' ) . download_file ( file_name , dest_path ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # This is a unit-testing file/module from my_library.my_resources import S3 from my_library.my_functions import download_file from moto import mock_s3 import tempfile import pytest @mock_s3 @pytest . mark . parametrize ( \"test_file\" , [ \"a-file-1.txt\" , \"a-file-2.txt\" ], ) def test_download_file ( test_file ): \"\"\" `test_download_file` will be executed twice, once for each parameterized value. At the start of each run of the `test_download_file` function (once for each parameterized value), the dependencies are cleared. This means `S3.grab()` will create a S3 resource for me lazily each time this unit-test function runs. And so I can have separate, independent tests that won't leak dependencies into the next function test-run. \"\"\" S3 . grab () . resource . Bucket ( 'my-bucket' ) . put_object ( Key = test_file , Body = b 'some-bytes' ) with tempfile . NamedTemporaryFile () as tmp : download_file ( test_file , tmp . name ) with open ( tmp . name , 'r' ) as file : assert file . read () == b 'some-bytes'","title":"Overview - pytest"},{"location":"unit-testing/#implementation-details","text":"This is just extra info in case your intrested. Before the start of each pytest unit-test function run, the current dependencies are deactivated and a new blank XContext (which contains the dependencies) is created. This means that by default, at the start of each running unit test function there will be no dependencies 'visible'. PyTest Plugin Details This project contains a pytest plugin to automatically install a brand-new app-root and thread-root XContext's at the start of each unit test run. This is important, it ensures a blank root-context is used each time a unit test executes. This is accomplished via an autouse=True fixture. The fixture is in a pytest plugin module. This plugin module is automatically found and loaded by pytest. pytest checks all installed dependencies in the environment it runs in, so as long as xinject is installed in the environment as a dependency it will find this and autoload this fixture for each unit test. If curious The xinject_test_context fixture is how it's implemented. The result is for each unit test executed via pytest, it will always start with no resources from a previous unit-test execution. So no dependencies changes/state will 'leak' between each unit test function run. Each unit-test will therefore always start out in the same state. This allows each unit test to run in any order, as it should not affect the dependencies of the next unit-test function that runs.","title":"Implementation Details"}]}